options {
    STATIC = false;
}

PARSER_BEGIN(Lovelace)

import java.io.*;

public class Lovelace {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Uso: java Lovelace <arquivo.lov>");
            return;
        }
        
        try {
            Lovelace parser = new Lovelace(new FileInputStream(args[0]));
            parser.Analise();
            System.out.println("\nAnálise léxica concluída com sucesso!");
        } catch (FileNotFoundException e) {
            System.err.println("Erro: Arquivo não encontrado - " + args[0]);
        } catch (Exception e) {
            System.err.println("Erro durante análise: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

PARSER_END(Lovelace)

/* TOKENS - IGNORAR ESPAÇOS EM BRANCO */
SKIP: {
    " " | "\t" | "\n" | "\r" | "\r\n"
}

/* COMENTÁRIOS */

/* PALAVRAS RESERVADAS */
TOKEN : {
    < MAIN: "main" >
  | < BEGIN: "begin" >
  | < END: "end" >
  | < LET: "let" >
  | < IF: "if" >
  | < WHILE: "while" >
  | < READ: "read" >
  | < RETURN: "return" >
  | < PRINT: "print" >
  | < DEF: "def" >
  | < COMMA: "," >
  | < SEMI: ";" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
}

/* tipos literais */
TOKEN : {
    < FLOAT_TYPE: "Float" >
  | < BOOL_TYPE: "Bool" >
  | < VOID_TYPE: "Void" >
}

/* booleanos literais */
TOKEN : {
    < TRUE: "true" >
  | < FALSE: "false" >
}

/* operadores (inclui lógicos &&, || e relacionais etc) */
TOKEN : {
    < AND: "&&" >
  | < OR: "||" >
  | < EQEQ: "==" >
  | < LT: "<" >
  | < GT: ">" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
}

/* atribuição token (:=) e vírgula já acima */
TOKEN : {
    < ATTR: ":=" >
}

/* identificador conforme convenção:
   letra (letra|digito)* ( "_" (letra|digito)+ )* 
   - permite partes finais com underscore seguidas de letras/dígitos
*/
TOKEN : {
    < ID:
        (["a"-"z","A"-"Z"]) 
        (["a"-"z","A"-"Z","0"-"9"])*
        ( ("_" (["a"-"z","A"-"Z","0"-"9"])+ ) )*
    >
}

/* número literal: digitos ( .digitos )? ( [Ee] (+|-)? digitos )? */
TOKEN : {
    < NUM_LITERAL:
        (["0"-"9"])+
        ( "." (["0"-"9"])+ )?
        ( ["E","e"] (["+","-"])? (["0"-"9"])+ )?
    >
}

/* ANÁLISE LÉXICA */
void Analise(): {
    Token t;
} {
    {
        try {
            while (true) {
                t = getNextToken();
                
                if (t.kind == EOF) break;
                
                switch (t.kind) {
                    // Palavras reservadas
                     case MAIN: System.out.println("Palavra reservada: main"); break;
                    case BEGIN: System.out.println("Palavra reservada: begin"); break;
                    case END: System.out.println("Palavra reservada: end"); break;
                    case LET: System.out.println("Palavra reservada: let"); break;
                    case IF: System.out.println("Palavra reservada: if"); break;
                    case WHILE: System.out.println("Palavra reservada: while"); break;
                    case READ: System.out.println("Palavra reservada: read"); break;
                    case RETURN: System.out.println("Palavra reservada: return"); break;
                    case PRINT: System.out.println("Palavra reservada: print"); break;
                    case DEF: System.out.println("Palavra reservada: def"); break;
                    
                    // Tipos
                    case FLOAT_TYPE: System.out.println("Tipo: Float"); break;
                    case BOOL_TYPE: System.out.println("Tipo: Bool"); break;
                    case VOID_TYPE: System.out.println("Tipo: Void"); break;
                    
                    // Valores booleanos
                    case TRUE: System.out.println("Valor booleano: true"); break;
                    case FALSE: System.out.println("Valor booleano: false"); break;
                    
                    // Operadores
                    case PLUS: System.out.println("Operador aritmético: +"); break;
                    case MINUS: System.out.println("Operador aritmético: -"); break;
                    case MULT: System.out.println("Operador aritmético: *"); break;
                    case DIV: System.out.println("Operador aritmético: /"); break;
                    case AND: System.out.println("Operador lógico: &&"); break;
                    case OR: System.out.println("Operador lógico: ||"); break;
                    case EQEQ: System.out.println("Operador relacional: =="); break;
                    case LT: System.out.println("Operador relacional: <"); break;
                    case GT: System.out.println("Operador relacional: >"); break;
                    case ATTR: System.out.println("Operador de atribuição: :="); break;

                    // Delimitadores e pontuação
                    case LPAREN: System.out.println("Abre parênteses: ("); break;
                    case RPAREN: System.out.println("Fecha parênteses: )"); break;
                    case COMMA: System.out.println("Vírgula: ,"); break;
                    case SEMI: System.out.println("Ponto e vírgula: ;"); break;

                    // Identificador
                    case ID: System.out.println("Identificador: " + t.image); break;

                    // Número literal
                    case NUM_LITERAL: System.out.println("Número literal: " + t.image); break;

                    default: System.out.println("Token desconhecido: " + t.image); break;
                }
            }
        } catch (Exception e) {
            System.err.println("Erro: " + e.getMessage());
        }
    }
}

/* Função inicial */
void LOVELACE() :
{}
{
    MAIN_PROD() FUNC_LIST() <EOF>
}

/* MAIN -> "main" "(" ")" "begin" VARDECL SEQCOMANDOS "end" */
void MAIN_PROD() :
{}
{
    <MAIN> <LPAREN> <RPAREN> <BEGIN> VARDECL() SEQCOMANDOS() <END>
}

/* VARDECL -> VARDECL "let" TIPO TOKEN_id ";" | vazio
   Implementado como zero ou mais declarações */
void VARDECL() :
{}
{
    ( <LET> TIPO() <ID> <SEMI> )*
}

/* TIPO -> "Float" | "Bool" | "Void" */
void TIPO() :
{}
{
    <FLOAT_TYPE> | <BOOL_TYPE> | <VOID_TYPE>
}

/* SEQCOMANDOS -> SEQCOMANDOS COMANDO | vazio
   Implementado como zero ou mais comandos */
void SEQCOMANDOS() :
{}
{
    ( COMANDO() )*
}

/* COMANDO -> TOKEN_id ":=" EXP ";"
            | TOKEN_id "(" LISTAEXP? ")" ";"
            | "if" EXP "begin" SEQCOMANDOS "end" ";"
            | "while" EXP "begin" SEQCOMANDOS "end" ";"
            | TOKEN_id ":=" "read" "(" ")" ";"
            | "return" EXP ";"
            | "print" EXP ";" */
void COMANDO() :
{}
{
      ( <ID> <ATTR> EXP() <SEMI> )
    | ( <ID> <LPAREN> ( LISTAEXP() )? <RPAREN> <SEMI> )
    | ( <IF> EXP() <BEGIN> SEQCOMANDOS() <END> <SEMI> )
    | ( <WHILE> EXP() <BEGIN> SEQCOMANDOS() <END> <SEMI> )
    | ( <ID> <ATTR> <READ> <LPAREN> <RPAREN> <SEMI> )
    | ( <RETURN> EXP() <SEMI> )
    | ( <PRINT> EXP() <SEMI> )
}

/* EXP -> "(" EXP OP EXP ")" | FATOR */
void EXP() :
{}
{
      ( <LPAREN> EXP() OP() EXP() <RPAREN> )
    | FATOR()
}

/* FATOR -> TOKEN_id | TOKEN_id "(" LISTAEXP? ")"
           | TOKEN_numliteral | "true" | "false" */
void FATOR() :
{}
{
      ( <ID> ( <LPAREN> ( LISTAEXP() )? <RPAREN> )? )
    | <NUM_LITERAL>
    | <TRUE>
    | <FALSE>
}

/* OP -> "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==" */
void OP() :
{}
{
      <PLUS>
    | <MINUS>
    | <MULT>
    | <DIV>
    | <AND>
    | <OR>
    | <LT>
    | <GT>
    | <EQEQ>
}

/* LISTAEXP -> EXP | LISTAEXP "," EXP
   Implementado como: EXP ("," EXP)* */
void LISTAEXP() :
{}
{
    EXP() ( <COMMA> EXP() )*
}

/* FUNC -> FUNC "def" TIPO TOKEN_id "(" LISTAARG? ")" "begin" VARDECL SEQCOMANDOS "end"
           | "def" TIPO TOKEN_id "(" LISTAARG? ")" "begin" VARDECL SEQCOMANDOS "end"
   Implementado como zero ou mais funções. */
void FUNC_LIST() :
{}
{
    ( FUNC() )*
}

void FUNC() :
{}
{
    <DEF> TIPO() <ID> <LPAREN> ( LISTAARG() )? <RPAREN> <BEGIN> VARDECL() SEQCOMANDOS() <END>
}

/* LISTAARG -> TIPO TOKEN_id | LISTAARG "," TIPO TOKEN_id
   Implementado como: TIPO ID ("," TIPO ID)* */
void LISTAARG() :
{}
{
    TIPO() <ID> ( <COMMA> TIPO() <ID> )*
}
options {
    STATIC = false;
}

PARSER_BEGIN(Lovelace)

import java.io.*;
import ast.*;

public class Lovelace {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Uso: java Lovelace <arquivo.lov>");
            return;
        }
        
        try {
            Lovelace parser = new Lovelace(new FileInputStream(args[0]));
            parser.Analise();
            System.out.println("\nAnálise léxica concluída com sucesso!");
	    Prog arvore = parser.Lovelace();
            System.out.println("\nAnálise sintática concluída com sucesso!");
	    geraCodigo(arvore, args[0]);
        } catch (FileNotFoundException e) {
            System.err.println("Erro: Arquivo não encontrado - " + args[0]);
        } catch (Exception e) {
            System.err.println("Erro durante análise: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

public static void geraCodigo(Prog prog, String arquivo) {

}

PARSER_END(Lovelace)

/* TOKENS - IGNORAR ESPAÇOS EM BRANCO */
SKIP: {
    " " | "\t" | "\n" | "\r" | "\r\n"
}

/* COMENTÁRIOS */

/* PALAVRAS RESERVADAS */
TOKEN : {
    < MAIN: "main" >
  | < BEGIN: "begin" >
  | < END: "end" >
  | < LET: "let" >
  | < IF: "if" >
  | < WHILE: "while" >
  | < READ: "read" >
  | < RETURN: "return" >
  | < PRINT: "print" >
  | < DEF: "def" >
  | < VIRGULA: "," >
  | < PONTO_VIRGULA: ";" >
  | < ABRE_PAR: "(" >
  | < FECHA_PAR: ")" >
}

/* tipos literais */
TOKEN : {
    < FLOAT: "Float" >
  | < BOOLEAN: "Bool" >
  | < VOID: "Void" >
}

/* booleanos literais */
TOKEN : {
    < TRUE: "true" >
  | < FALSE: "false" >
}

/* operadores (inclui lógicos &&, || e relacionais etc) */
TOKEN : {
    < AND: "&&" >
  | < OR: "||" >
  | < IGUAL: "==" >
  | < MENOR: "<" >
  | < MAIOR: ">" >
  | < MAIS: "+" >
  | < MENOS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
}

/* atribuição token (:=) e vírgula já acima */
TOKEN : {
    < ATRIBUICAO: ":=" >
}

/* identificador conforme convenção:
   letra (letra|digito)* ( "_" (letra|digito)+ )* 
   - permite partes finais com underscore seguidas de letras/dígitos
*/
TOKEN : {
    < IDENTIFICADOR:
        (["a"-"z","A"-"Z"]) 
        (["a"-"z","A"-"Z","0"-"9"])*
        ( ("_" (["a"-"z","A"-"Z","0"-"9"])+ ) )*
    >
}

/* número literal: digitos ( .digitos )? ( [Ee] (+|-)? digitos )? */
TOKEN : {
    < NUM:
        (["0"-"9"])+
        ( "." (["0"-"9"])+ )?
        ( ["E","e"] (["+","-"])? (["0"-"9"])+ )?
    >
}

/* ANÁLISE LÉXICA */
void Analise(): {
    Token t;
} {
    {
        try {
            while (true) {
                t = getNextToken();
                
                if (t.kind == EOF) break;
                
                switch (t.kind) {
                    // Palavras reservadas
                     case MAIN: System.out.println("Palavra reservada: main"); break;
                    case BEGIN: System.out.println("Palavra reservada: begin"); break;
                    case END: System.out.println("Palavra reservada: end"); break;
                    case LET: System.out.println("Palavra reservada: let"); break;
                    case IF: System.out.println("Palavra reservada: if"); break;
                    case WHILE: System.out.println("Palavra reservada: while"); break;
                    case READ: System.out.println("Palavra reservada: read"); break;
                    case RETURN: System.out.println("Palavra reservada: return"); break;
                    case PRINT: System.out.println("Palavra reservada: print"); break;
                    case DEF: System.out.println("Palavra reservada: def"); break;
                    
                    // Tipos
                    case FLOAT: System.out.println("Tipo: Float"); break;
                    case BOOLEAN: System.out.println("Tipo: Bool"); break;
                    case VOID: System.out.println("Tipo: Void"); break;
                    
                    // Valores booleanos
                    case TRUE: System.out.println("Valor booleano: true"); break;
                    case FALSE: System.out.println("Valor booleano: false"); break;
                    
                    // Operadores
                    case MAIS: System.out.println("Operador aritmético: +"); break;
                    case MENOS: System.out.println("Operador aritmético: -"); break;
                    case MULT: System.out.println("Operador aritmético: *"); break;
                    case DIV: System.out.println("Operador aritmético: /"); break;
                    case AND: System.out.println("Operador lógico: &&"); break;
                    case OR: System.out.println("Operador lógico: ||"); break;
                    case IGUAL: System.out.println("Operador relacional: =="); break;
                    case MENOR: System.out.println("Operador relacional: <"); break;
                    case MAIOR: System.out.println("Operador relacional: >"); break;
                    case ATRIBUICAO: System.out.println("Operador de atribuição: :="); break;

                    // Delimitadores e pontuação
                    case ABRE_PAR: System.out.println("Abre parênteses: ("); break;
                    case FECHA_PAR: System.out.println("Fecha parênteses: )"); break;
                    case VIRGULA: System.out.println("Vírgula: ,"); break;
                    case PONTO_VIRGULA: System.out.println("Ponto e vírgula: ;"); break;

                    // Identificador
                    case IDENTIFICADOR: System.out.println("Identificador: " + t.image); break;

                    // Número literal
                    case NUM: System.out.println("Número: " + t.image); break;

                    default: System.out.println("Token desconhecido: " + t.image); break;
                }
            }
        } catch (Exception e) {
            System.err.println("Erro: " + e.getMessage());
        }
    }
}

/* ANÁLISE SINTÁTICA */

// Função inicial Lovelace
Prog Lovelace () :
{Main main=null; ArrayList<Fun> funs = null;}
{

main=LovMain() (funs=Func())?
<EOF>

{return new Prog(main,funs);}

}

// Main
Main LovMain () :
{public ArrayList<VarDecl> vars=null;
 public ArrayList<Comando> coms=null;}
{

<MAIN> <ABRE_PAR> <FECHA_PAR> <BEGIN> vars=VarDecls() coms=SeqComandos() <END>

{return new Main(vars,coms);}
}


ArrayList<VarDecl> VarDecls() :
{ArrayList<VarDecl> decls = new ArrayList<VarDecl>(); String nome=null; String tipo=null;} // Lista dos comandos na classe designada
{

(<LET> tipo=Tipo() nome=<IDENTIFICADOR> <PONTO_VIRGULA>

 {
     decls.add(new VarDecl(tipo,nome.image);)

 }
)*

{return decls;}

}

void Tipo() :
{}
{

<FLOAT>
| <BOOLEAN>
| <VOID>

}

ArrayList<Comando> SeqComandos() :
{ArrayList<Comando> comandos = new ArrayList<Comando>();}  // Lista dos comandos na classe designada
{

//Com() SeqComandosL()
Com()*

}

/*void SeqComandosL() :
{}
{

(Com() SeqComandosL())?

}*/

Comando Com() :
{Comando}
{

<IDENTIFICADOR> ComId()
| <IF> Exp() <BEGIN> SeqComandos() <END> <PONTO_VIRGULA>
| <WHILE> Exp() <BEGIN> SeqComandos() <END> <PONTO_VIRGULA>
| <RETURN> Exp() <PONTO_VIRGULA>
| <PRINT> Exp() <PONTO_VIRGULA>

}

String ComId() : // acho que é isso, checar dps 
{}
{

<ATRIBUICAO> ComIdPar()
| <ABRE_PAR> (ListaExp())? <FECHA_PAR> <PONTO_VIRGULA>

}

void ComIdPar() :
{}
{

Exp() <PONTO_VIRGULA>
|<READ> <ABRE_PAR> <FECHA_PAR> <PONTO_VIRGULA>

} 

void Exp() :
{}
{

<ABRE_PAR> ExpD() Op() ExpD() <FECHA_PAR>
| Fator()

}

void ExpD() :
{}
{

Fator() ExpDD()

}

void ExpDD() :
{}
{

(Op() Exp())?

}

void Fator() :
{}
{

<IDENTIFICADOR> FatorId()
| <NUM>
| <TRUE>
| <FALSE>

}

void FatorId() :
{}
{

(<ABRE_PAR> (ListaExp()) <FECHA_PAR>)?

}

void Op() :
{}
{

<MAIS>
| <MENOS>
| <MULT>
| <DIV>

}

void ListaExp() :
{}
{

Exp() ListaExpL()

}

void ListaExpL() :
{}
{

(<VIRGULA> Exp() ListaExpL())?

}

void Func() :
{}
{

<DEF> Tipo() <IDENTIFICADOR> <ABRE_PAR> (ListaArg())? <FECHA_PAR> <BEGIN> VarDecls() SeqComandos()
<END> FuncL()

}

void FuncL() :
{}
{

(Func() FuncL())?

}

void ListaArg() :
{}
{

Tipo() <IDENTIFICADOR> ListaArgL()

}

void ListaArgL() :
{}
{

(<VIRGULA> Tipo() <IDENTIFICADOR> ListaArgL())?

}

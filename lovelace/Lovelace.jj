options {
    STATIC = false;
}

PARSER_BEGIN(Lovelace)

import java.io.*;

public class Lovelace {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Uso: java Lovelace <arquivo.lov>");
            return;
        }
        
        try {
            Lovelace parser = new Lovelace(new FileInputStream(args[0]));
            parser.Analise();
            System.out.println("\nAnálise léxica concluída com sucesso!");
	    parser.Lovelace();
            System.out.println("\nAnálise sintática concluída com sucesso!");
        } catch (FileNotFoundException e) {
            System.err.println("Erro: Arquivo não encontrado - " + args[0]);
        } catch (Exception e) {
            System.err.println("Erro durante análise: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

PARSER_END(Lovelace)

/* TOKENS - IGNORAR ESPAÇOS EM BRANCO */
SKIP: {
    " " | "\t" | "\n" | "\r" | "\r\n"
}

/* COMENTÁRIOS */

/* PALAVRAS RESERVADAS */
TOKEN : {
    < MAIN: "main" >
  | < BEGIN: "begin" >
  | < END: "end" >
  | < LET: "let" >
  | < IF: "if" >
  | < WHILE: "while" >
  | < READ: "read" >
  | < RETURN: "return" >
  | < PRINT: "print" >
  | < DEF: "def" >
  | < VIRGULA: "," >
  | < PONTO_VIRGULA: ";" >
  | < ABRE_PAR: "(" >
  | < FECHA_PAR: ")" >
}

/* tipos literais */
TOKEN : {
    < FLOAT: "Float" >
  | < BOOLEAN: "Bool" >
  | < VOID: "Void" >
}

/* booleanos literais */
TOKEN : {
    < TRUE: "true" >
  | < FALSE: "false" >
}

/* operadores (inclui lógicos &&, || e relacionais etc) */
TOKEN : {
    < AND: "&&" >
  | < OR: "||" >
  | < IGUAL: "==" >
  | < MENOR: "<" >
  | < MAIOR: ">" >
  | < MAIS: "+" >
  | < MENOS: "-" >
  | < MULT: "*" >
  | < DIV: "/" >
}

/* atribuição token (:=) e vírgula já acima */
TOKEN : {
    < ATRIBUICAO: ":=" >
}

/* identificador conforme convenção:
   letra (letra|digito)* ( "_" (letra|digito)+ )* 
   - permite partes finais com underscore seguidas de letras/dígitos
*/
TOKEN : {
    < IDENTIFICADOR:
        (["a"-"z","A"-"Z"]) 
        (["a"-"z","A"-"Z","0"-"9"])*
        ( ("_" (["a"-"z","A"-"Z","0"-"9"])+ ) )*
    >
}

/* número literal: digitos ( .digitos )? ( [Ee] (+|-)? digitos )? */
TOKEN : {
    < NUM:
        (["0"-"9"])+
        ( "." (["0"-"9"])+ )?
        ( ["E","e"] (["+","-"])? (["0"-"9"])+ )?
    >
}

/* ANÁLISE LÉXICA */
void Analise(): {
    Token t;
} {
    {
        try {
            while (true) {
                t = getNextToken();
                
                if (t.kind == EOF) break;
                
                switch (t.kind) {
                    // Palavras reservadas
                     case MAIN: System.out.println("Palavra reservada: main"); break;
                    case BEGIN: System.out.println("Palavra reservada: begin"); break;
                    case END: System.out.println("Palavra reservada: end"); break;
                    case LET: System.out.println("Palavra reservada: let"); break;
                    case IF: System.out.println("Palavra reservada: if"); break;
                    case WHILE: System.out.println("Palavra reservada: while"); break;
                    case READ: System.out.println("Palavra reservada: read"); break;
                    case RETURN: System.out.println("Palavra reservada: return"); break;
                    case PRINT: System.out.println("Palavra reservada: print"); break;
                    case DEF: System.out.println("Palavra reservada: def"); break;
                    
                    // Tipos
                    case FLOAT: System.out.println("Tipo: Float"); break;
                    case BOOLEAN: System.out.println("Tipo: Bool"); break;
                    case VOID: System.out.println("Tipo: Void"); break;
                    
                    // Valores booleanos
                    case TRUE: System.out.println("Valor booleano: true"); break;
                    case FALSE: System.out.println("Valor booleano: false"); break;
                    
                    // Operadores
                    case MAIS: System.out.println("Operador aritmético: +"); break;
                    case MENOS: System.out.println("Operador aritmético: -"); break;
                    case MULT: System.out.println("Operador aritmético: *"); break;
                    case DIV: System.out.println("Operador aritmético: /"); break;
                    case AND: System.out.println("Operador lógico: &&"); break;
                    case OR: System.out.println("Operador lógico: ||"); break;
                    case IGUAL: System.out.println("Operador relacional: =="); break;
                    case MENOR: System.out.println("Operador relacional: <"); break;
                    case MAIOR: System.out.println("Operador relacional: >"); break;
                    case ATRIBUICAO: System.out.println("Operador de atribuição: :="); break;

                    // Delimitadores e pontuação
                    case ABRE_PAR: System.out.println("Abre parênteses: ("); break;
                    case FECHA_PAR: System.out.println("Fecha parênteses: )"); break;
                    case VIRGULA: System.out.println("Vírgula: ,"); break;
                    case PONTO_VIRGULA: System.out.println("Ponto e vírgula: ;"); break;

                    // Identificador
                    case IDENTIFICADOR: System.out.println("Identificador: " + t.image); break;

                    // Número literal
                    case NUM: System.out.println("Número: " + t.image); break;

                    default: System.out.println("Token desconhecido: " + t.image); break;
                }
            }
        } catch (Exception e) {
            System.err.println("Erro: " + e.getMessage());
        }
    }
}

/* ANÁLISE SINTÁTICA */

// Função inicial Lovelace
void Lovelace () :
{}
{

LovMain() (Func())?
<EOF>
}

// Main
void LovMain () :
{}
{

<MAIN> <ABRE_PAR> <FECHA_PAR> <BEGIN> VarDecls() SeqComandos() <END>

}

void VarDecls () :
{}
{

VarDecl() <PONTO_VIRGULA> VarDeclsL()

}

void VarDeclsL() :
{}
{

( VarDecl() <PONTO_VIRGULA> VarDeclsL())?

}

void VarDecl() :
{}
{

<LET> Tipo() <IDENTIFICADOR> <PONTO_VIRGULA>

}

void Tipo() :
{}
{

<FLOAT>
| <BOOLEAN>
| <VOID>

}

void SeqComandos() :
{}
{

Com() SeqComandosL()

}

void SeqComandosL() :
{}
{

(Com() SeqComandosL())?

}

void Com() :
{}
{

<IDENTIFICADOR> <ATRIBUICAO> Exp() <PONTO_VIRGULA>
| <IDENTIFICADOR> <ABRE_PAR> (ListaExp())? <FECHA_PAR> <PONTO_VIRGULA>
| <IF> Exp() <BEGIN> SeqComandos() <END> <PONTO_VIRGULA>
| <WHILE> Exp() <BEGIN> SeqComandos() <END> <PONTO_VIRGULA>
| <IDENTIFICADOR> <ATRIBUICAO> <READ> <ABRE_PAR> <FECHA_PAR> <PONTO_VIRGULA>
| <RETURN> Exp() <PONTO_VIRGULA>
| <PRINT> Exp() <PONTO_VIRGULA>

}

void Exp() :
{}
{

<ABRE_PAR> ExpD() Op() ExpD() <FECHA_PAR>
| Fator()

}

void ExpD() :
{}
{

Fator() ExpDD()

}

void ExpDD() :
{}
{

(Op() Exp())?

}

void Fator() :
{}
{

<IDENTIFICADOR>
| <IDENTIFICADOR> <ABRE_PAR> (ListaExp()) <FECHA_PAR>
| <NUM>
| <TRUE>
| <FALSE>

}

void Op() :
{}
{

<MAIS>
| <MENOS>
| <MULT>
| <DIV>

}

void ListaExp() :
{}
{

Exp() ListaExpL()

}

void ListaExpL() :
{}
{

(<VIRGULA> Exp() ListaExpL())?

}

void Func() :
{}
{

<DEF> Tipo() <IDENTIFICADOR> <ABRE_PAR> (ListaArg())? <FECHA_PAR> <BEGIN> VarDecls() SeqComandos()
<END> FuncL()

}

void FuncL() :
{}
{

(Func() FuncL())?

}

void ListaArg() :
{}
{

Tipo() <IDENTIFICADOR> ListaArgL()

}

void ListaArgL() :
{}
{

(<VIRGULA> Tipo() <IDENTIFICADOR> ListaArgL())?

}
